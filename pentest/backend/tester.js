// Security test definitions
const securityTests = [
  {
    id: 'AUTH_MISSING',
    name: 'Missing Authentication',
    description: 'Tests if protected endpoints can be accessed without authentication',
    severity: 'HIGH',
    category: 'Authentication'
  },
  {
    id: 'SQL_INJECTION',
    name: 'SQL Injection',
    description: 'Tests for SQL injection vulnerabilities by sending malicious payloads',
    severity: 'HIGH',
    category: 'Injection'
  },
  {
    id: 'NOSQL_INJECTION',
    name: 'NoSQL Injection',
    description: 'Tests for NoSQL injection vulnerabilities in MongoDB-style queries',
    severity: 'HIGH',
    category: 'Injection'
  },
  {
    id: 'RATE_LIMITING',
    name: 'Rate Limiting',
    description: 'Tests if the API has rate limiting protection against brute force attacks',
    severity: 'MEDIUM',
    category: 'Availability'
  },
  {
    id: 'SECURITY_HEADERS',
    name: 'Security Headers',
    description: 'Checks for missing or misconfigured security headers',
    severity: 'MEDIUM',
    category: 'Configuration'
  },
  {
    id: 'SENSITIVE_DATA_EXPOSURE',
    name: 'Sensitive Data Exposure',
    description: 'Checks for sensitive data leakage in responses and error messages',
    severity: 'HIGH',
    category: 'Data Protection'
  }
];

// SQL Injection payloads
const sqlPayloads = [
  "' OR '1'='1",
  "'; DROP TABLE users;--",
  "' UNION SELECT * FROM users--",
  "1' AND '1'='1",
  "admin'--"
];

// NoSQL Injection payloads
const nosqlPayloads = [
  '{"$gt": ""}',
  '{"$ne": null}',
  '{"$where": "1==1"}',
  '{"$regex": ".*"}'
];

// Required security headers
const requiredHeaders = [
  { name: 'X-Content-Type-Options', expected: 'nosniff' },
  { name: 'X-Frame-Options', expected: ['DENY', 'SAMEORIGIN'] },
  { name: 'X-XSS-Protection', expected: '1; mode=block' },
  { name: 'Strict-Transport-Security', expected: null },
  { name: 'Content-Security-Policy', expected: null }
];

// Patterns indicating sensitive data exposure
const sensitivePatterns = [
  { pattern: /password/i, type: 'Password field exposed' },
  { pattern: /api[_-]?key/i, type: 'API key exposed' },
  { pattern: /secret/i, type: 'Secret field exposed' },
  { pattern: /stack.*trace/i, type: 'Stack trace exposed' },
  { pattern: /exception|error.*at\s+\w+/i, type: 'Detailed error exposed' },
  { pattern: /mongodb:\/\//i, type: 'Database connection string exposed' },
  { pattern: /mysql:\/\//i, type: 'Database connection string exposed' }
];

// Helper function to make HTTP requests
const makeRequest = async (url, options = {}) => {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), options.timeout || 10000);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    clearTimeout(timeout);

    const headers = {};
    response.headers.forEach((value, key) => {
      headers[key] = value;
    });

    let body = null;
    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      try {
        body = await response.json();
      } catch (e) {
        body = await response.text();
      }
    } else {
      body = await response.text();
    }

    return {
      status: response.status,
      statusText: response.statusText,
      headers,
      body
    };
  } catch (error) {
    clearTimeout(timeout);
    throw error;
  }
};

// Test: Missing Authentication
const testMissingAuth = async (targetUrl, options) => {
  const result = {
    id: 'AUTH_MISSING',
    name: 'Missing Authentication',
    status: 'PASS',
    severity: 'HIGH',
    findings: [],
    details: ''
  };

  try {
    const response = await makeRequest(targetUrl, { method: 'GET' });

    if (response.status === 200) {
      const bodyStr = typeof response.body === 'string' ? response.body : JSON.stringify(response.body);
      
      if (bodyStr.length > 50) {
        result.status = 'WARNING';
        result.findings.push({
          issue: 'Endpoint accessible without authentication',
          evidence: `Received ${response.status} response with data`
        });
        result.details = 'The endpoint returns data without requiring authentication. Verify if this is intentional.';
      }
    } else if (response.status === 401 || response.status === 403) {
      result.status = 'PASS';
      result.details = 'Endpoint properly requires authentication.';
    }
  } catch (error) {
    result.status = 'ERROR';
    result.details = `Could not complete test: ${error.message}`;
  }

  return result;
};

// Test: SQL Injection
const testSqlInjection = async (targetUrl, options) => {
  const result = {
    id: 'SQL_INJECTION',
    name: 'SQL Injection',
    status: 'PASS',
    severity: 'HIGH',
    findings: [],
    details: ''
  };

  try {
    for (const payload of sqlPayloads) {
      const testUrl = new URL(targetUrl);
      testUrl.searchParams.set('id', payload);
      testUrl.searchParams.set('search', payload);

      try {
        const response = await makeRequest(testUrl.toString(), { method: 'GET' });
        const bodyStr = typeof response.body === 'string' ? response.body : JSON.stringify(response.body);

        if (bodyStr.match(/sql|syntax|mysql|postgresql|oracle|sqlite/i) ||
            bodyStr.match(/error.*query|query.*error/i) ||
            bodyStr.match(/ORA-\d{5}|PLS-\d{5}/)) {
          result.status = 'FAIL';
          result.findings.push({
            issue: 'Potential SQL injection vulnerability',
            payload: payload,
            evidence: 'SQL-related error message detected in response'
          });
        }
      } catch (e) {
        // Continue testing other payloads
      }

      try {
        const response = await makeRequest(targetUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username: payload, password: payload, id: payload })
        });
        const bodyStr = typeof response.body === 'string' ? response.body : JSON.stringify(response.body);

        if (bodyStr.match(/sql|syntax|mysql|postgresql|oracle|sqlite/i)) {
          result.status = 'FAIL';
          result.findings.push({
            issue: 'Potential SQL injection in POST body',
            payload: payload,
            evidence: 'SQL-related error message detected in response'
          });
        }
      } catch (e) {
        // Continue testing
      }
    }

    if (result.findings.length === 0) {
      result.details = 'No SQL injection vulnerabilities detected with tested payloads.';
    } else {
      result.details = `Found ${result.findings.length} potential SQL injection issue(s).`;
    }
  } catch (error) {
    result.status = 'ERROR';
    result.details = `Could not complete test: ${error.message}`;
  }

  return result;
};

// Test: NoSQL Injection
const testNosqlInjection = async (targetUrl, options) => {
  const result = {
    id: 'NOSQL_INJECTION',
    name: 'NoSQL Injection',
    status: 'PASS',
    severity: 'HIGH',
    findings: [],
    details: ''
  };

  try {
    for (const payload of nosqlPayloads) {
      try {
        const response = await makeRequest(targetUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            username: JSON.parse(payload),
            password: JSON.parse(payload)
          })
        });

        if (response.status === 200 && response.body) {
          const bodyStr = typeof response.body === 'string' ? response.body : JSON.stringify(response.body);
          
          if (bodyStr.match(/mongodb|mongoose|mongo/i) ||
              (Array.isArray(response.body) && response.body.length > 1)) {
            result.status = 'FAIL';
            result.findings.push({
              issue: 'Potential NoSQL injection vulnerability',
              payload: payload,
              evidence: 'Unexpected data returned or MongoDB error detected'
            });
          }
        }
      } catch (e) {
        // Continue testing other payloads
      }
    }

    if (result.findings.length === 0) {
      result.details = 'No NoSQL injection vulnerabilities detected with tested payloads.';
    } else {
      result.details = `Found ${result.findings.length} potential NoSQL injection issue(s).`;
    }
  } catch (error) {
    result.status = 'ERROR';
    result.details = `Could not complete test: ${error.message}`;
  }

  return result;
};

// Test: Rate Limiting
const testRateLimiting = async (targetUrl, options) => {
  const result = {
    id: 'RATE_LIMITING',
    name: 'Rate Limiting',
    status: 'PASS',
    severity: 'MEDIUM',
    findings: [],
    details: ''
  };

  const requestCount = options.rateLimitRequests || 20;
  let successCount = 0;
  let rateLimitedCount = 0;

  try {
    const requests = [];
    
    for (let i = 0; i < requestCount; i++) {
      requests.push(makeRequest(targetUrl, { method: 'GET' }));
    }

    const responses = await Promise.allSettled(requests);

    for (const response of responses) {
      if (response.status === 'fulfilled') {
        if (response.value.status === 429) {
          rateLimitedCount++;
        } else if (response.value.status === 200) {
          successCount++;
        }
      }
    }

    if (rateLimitedCount === 0 && successCount === requestCount) {
      result.status = 'FAIL';
      result.findings.push({
        issue: 'No rate limiting detected',
        evidence: `All ${requestCount} rapid requests succeeded without rate limiting`
      });
      result.details = `The API does not appear to have rate limiting. ${requestCount} requests were sent and all succeeded.`;
    } else if (rateLimitedCount > 0) {
      result.status = 'PASS';
      result.details = `Rate limiting is active. ${rateLimitedCount} out of ${requestCount} requests were rate limited.`;
    } else {
      result.status = 'WARNING';
      result.details = `Inconclusive results. ${successCount} succeeded, ${rateLimitedCount} rate limited.`;
    }
  } catch (error) {
    result.status = 'ERROR';
    result.details = `Could not complete test: ${error.message}`;
  }

  return result;
};

// Test: Security Headers
const testSecurityHeaders = async (targetUrl, options) => {
  const result = {
    id: 'SECURITY_HEADERS',
    name: 'Security Headers',
    status: 'PASS',
    severity: 'MEDIUM',
    findings: [],
    details: ''
  };

  try {
    const response = await makeRequest(targetUrl, { method: 'GET' });
    const headers = response.headers;

    for (const required of requiredHeaders) {
      const headerValue = headers[required.name.toLowerCase()];

      if (!headerValue) {
        result.findings.push({
          issue: `Missing security header: ${required.name}`,
          recommendation: `Add the ${required.name} header to responses`
        });
      } else if (required.expected) {
        const expectedValues = Array.isArray(required.expected) ? required.expected : [required.expected];
        if (!expectedValues.some(exp => headerValue.includes(exp))) {
          result.findings.push({
            issue: `Misconfigured header: ${required.name}`,
            current: headerValue,
            expected: expectedValues.join(' or ')
          });
        }
      }
    }

    if (headers['server']) {
      result.findings.push({
        issue: 'Server header exposes technology information',
        evidence: `Server: ${headers['server']}`,
        recommendation: 'Consider removing or obfuscating the Server header'
      });
    }

    if (headers['x-powered-by']) {
      result.findings.push({
        issue: 'X-Powered-By header exposes technology information',
        evidence: `X-Powered-By: ${headers['x-powered-by']}`,
        recommendation: 'Remove the X-Powered-By header'
      });
    }

    if (result.findings.length > 0) {
      result.status = 'FAIL';
      result.details = `Found ${result.findings.length} security header issue(s).`;
    } else {
      result.details = 'All recommended security headers are properly configured.';
    }
  } catch (error) {
    result.status = 'ERROR';
    result.details = `Could not complete test: ${error.message}`;
  }

  return result;
};

// Test: Sensitive Data Exposure
const testSensitiveDataExposure = async (targetUrl, options) => {
  const result = {
    id: 'SENSITIVE_DATA_EXPOSURE',
    name: 'Sensitive Data Exposure',
    status: 'PASS',
    severity: 'HIGH',
    findings: [],
    details: ''
  };

  try {
    const response = await makeRequest(targetUrl, { method: 'GET' });
    const bodyStr = typeof response.body === 'string' ? response.body : JSON.stringify(response.body);

    for (const check of sensitivePatterns) {
      if (check.pattern.test(bodyStr)) {
        result.findings.push({
          issue: check.type,
          evidence: 'Sensitive pattern found in response body'
        });
      }
    }

    try {
      const errorResponse = await makeRequest(targetUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: 'invalid json{'
      });
      const errorBodyStr = typeof errorResponse.body === 'string' ? errorResponse.body : JSON.stringify(errorResponse.body);

      for (const check of sensitivePatterns) {
        if (check.pattern.test(errorBodyStr)) {
          result.findings.push({
            issue: `${check.type} in error response`,
            evidence: 'Sensitive pattern found in error response'
          });
        }
      }

      if (errorBodyStr.length > 500) {
        result.findings.push({
          issue: 'Verbose error message',
          evidence: `Error response is ${errorBodyStr.length} characters long`,
          recommendation: 'Reduce error message verbosity in production'
        });
      }
    } catch (e) {
      // Continue with test
    }

    if (result.findings.length > 0) {
      result.status = 'FAIL';
      result.details = `Found ${result.findings.length} sensitive data exposure issue(s).`;
    } else {
      result.details = 'No sensitive data exposure detected.';
    }
  } catch (error) {
    result.status = 'ERROR';
    result.details = `Could not complete test: ${error.message}`;
  }

  return result;
};

// Map test IDs to functions
const testFunctions = {
  'AUTH_MISSING': testMissingAuth,
  'SQL_INJECTION': testSqlInjection,
  'NOSQL_INJECTION': testNosqlInjection,
  'RATE_LIMITING': testRateLimiting,
  'SECURITY_HEADERS': testSecurityHeaders,
  'SENSITIVE_DATA_EXPOSURE': testSensitiveDataExposure
};

// Get list of available tests
export const getAvailableTests = () => {
  return securityTests;
};

// Run all security tests
export const runAllTests = async (targetUrl, options = {}) => {
  const results = [];

  for (const test of securityTests) {
    const testFn = testFunctions[test.id];
    if (testFn) {
      const result = await testFn(targetUrl, options);
      results.push(result);
    }
  }

  return results;
};

// Run a specific test
export const runSpecificTest = async (testId, targetUrl, options = {}) => {
  const testFn = testFunctions[testId];
  if (!testFn) {
    return null;
  }
  return await testFn(targetUrl, options);
};

export default { getAvailableTests, runAllTests, runSpecificTest };